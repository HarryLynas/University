#include "codeGeneration.h"

void codeGenerateFromTree(tree & AST, std::string fileName,
	std::unordered_map<std::string, SymbolTableRecord*> * SymbolTable)
{
	// Optimise
	peepHoleOptimisation(AST, SymbolTable);
	
	// Compile
	fileName += ".lua";
	std::fstream file;
	file.open(fileName, std::fstream::out);

	// Output compiler info
	file << "-- Script generated by Harry Lynas' basic C to Lua compiler.\n\nprint(\""
		<< fileName.c_str() << " was compiled on: " << __DATE__ << " at "
		<< __TIME__ << " by Harry Lynas' basic C to Lua compiler.\")\n\n";

	parseTreeNode(AST.root, file, SymbolTable);

	// Always call the main function
	file << "\n-- Automatically call main upon script being run\n-- if there is a return print it\n";
	file << "local isReturn = main()\nif (isReturn) then\n\tprint(tostring(isReturn))\nend\n";

	file.close();
}

void parseTreeNode(node * leaf, std::fstream & file,
	std::unordered_map<std::string, SymbolTableRecord*> * SymbolTable)
{
	// check for / 0
	if (leaf->warning)
		file << "--[[ WARNING: Divide by zero. ]] ";

	// Process leaf
	if (leaf->value >= 500)
		file << leaf->variable;
	else
	{
		switch (leaf->value)
		{
			case MAIN:
				file << "function main";
				break;
			case INT:
				file << "local ";
				break;
			case OPENPARENTHESIS:
				file << "(";
				break;
			case CLOSEPARENTHESIS:
				file << ")";
				break;
			case OPENLATINBRACE:
				file << "\n";
				break;
			case CLOSELATINBRACE:
				file << "end\n";
				break;
			case TIMES:
				file << " * ";
				break;
			case COMMA:
				file << ", ";
				break;
			case SEMICOLON:
				file << "\n";
				break;
			case POINT:
				file << ".";
				break;
				break;
			case OPENANGLE:
				file << "<";
				break;
			case CLOSEANGLE:
				file << ">";
				break;
			case PLUS:
				file << " + ";
				break;
			case MINUS:
				file << " - ";
				break;
			case ASSIGN:
				file << " = ";
				break;
			case HASH:
				file << "#";
				break;
			case DIVIDE:
				file << " / ";
				break;
			case LOCAL_VARIABLE:
				file << leaf->variable;
				break;
			case RETURN:
				file << "return ";
				break;
			default:
				file << "\nprint(\"ERROR: Unsupported character: "
					<< leaf->value << " | \\" << char(leaf->value) << "\")\n";
		}
	}

	// go left
	if (leaf->left != NULL)
		parseTreeNode(leaf->left, file, SymbolTable);
	// go right
	if (leaf->right != NULL)
		parseTreeNode(leaf->right, file, SymbolTable);
}

void peepHoleOptimisation(tree & AST, std::unordered_map<std::string, SymbolTableRecord*> * SymbolTable)
{
	// It is more effecient to do X + X than X * 2, so find and replace these
	peepTreeNode(AST.root, SymbolTable);
}

void peepTreeNode(node * leaf, std::unordered_map<std::string, SymbolTableRecord*> * SymbolTable)
{
	// If right is 42 (*)
	if (leaf->right != NULL && leaf->right->value == TIMES)
		// If left is == left of 42 (*)
		if (leaf->left != NULL && leaf->right->left != NULL)
			if (leaf->right->left->variable.compare(leaf->left->variable) == 0)
				// Replace 42 with +
				leaf->right->value = PLUS;

	// Navigate through entire tree
	if (leaf->left != NULL)
		peepTreeNode(leaf->left, SymbolTable);
	if (leaf->right != NULL)
		peepTreeNode(leaf->right, SymbolTable);
}